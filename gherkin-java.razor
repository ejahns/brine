//	  This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
//
//	  Changes to this file may cause incorrect behavior and will be lost if
//	  the code is regenerated.
@using Berp;
package com.github.ejahns;

import java.util.List;
import java.util.ArrayDeque;
import java.util.Queue;

import com.github.ejahns.ParserException.*;
@foreach(var rule in Model.RuleSet.DerivedRules.Where(r => !r.TempRule))
{<text>import com.github.ejahns.model.@(rule.Name);
</text>}

import static com.github.ejahns.Parser.TokenType.*;
import static java.util.Arrays.*;

public class @Model.ParserClassName {

	private GherkinElementStackHandler stackHandler = new GherkinElementStackHandler();
	private TokenQueue queue;

	public enum TokenType {
		@foreach(var rule in Model.RuleSet.TokenRules)
		{<text>		@rule.Name.Replace("#", "")Token,
</text>}		;
		@@Override
		public String toString() {
			return name().replace("Token", "");
		}
		}

	public @Model.RuleSet.StartRule.Name parse(TokenQueue queue) {
		this.queue = queue;
		stackHandler.push(@(Model.RuleSet.StartRule.Name).class);
		int state = 0;
		Token token;
		do {
			token = queue.next();
			state = matchToken(state, token);
		} while (!token.isEOF());

		stackHandler.collapse(@(Model.RuleSet.StartRule.Name).class);

		return stackHandler.resolve();
	}

	private int matchToken(int state, Token token) {
		int newState;
		switch(state) {
		@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
		{
			@:case @state.Id:
				@:newState = matchTokenAt_@(state.Id)(token);
				@:break;
		}
			default:
				throw new IllegalStateException("Unknown state: " + state);
		}
		return newState;
	}
@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
{
<text>
	// @Raw(state.Comment)
	private int matchTokenAt_@(state.Id)(Token token) {
		@foreach(var transition in state.Transitions)
		{
		@:if (@matchToken(transition.TokenType)) {
			if (transition.LookAheadHint != null)
			{
			@:if (lookahead_@(transition.LookAheadHint.Id)(token))
			@:{
			}
			foreach(var production in transition.Productions)
			{
				@CallProduction(production)
			}
			@:return @transition.TargetState;
			if (transition.LookAheadHint != null)
			{
			@:}
			}
		@:}
		}
		@HandleParserError(state.Transitions.Select(t => t.TokenType.ToString()).Distinct())
	}</text>
}
@foreach(var lookAheadHint in Model.RuleSet.LookAheadHints)
{
<text>
	private boolean lookahead_@(lookAheadHint.Id)(Token currentToken) {
		Token token;
		Queue<Token> newQueue = new ArrayDeque<Token>();
		boolean match = false;
		do
		{
			token = queue.next();
			newQueue.add(token);

			if (false
			@foreach(var tokenType in lookAheadHint.ExpectedTokens)
			{
				@:|| @matchToken(tokenType)
			}
			)
			{
				match = true;
				break;
			}
		} while (false
		@foreach(var tokenType in lookAheadHint.Skip)
		{
			@:|| @matchToken(tokenType)
		}
		);
		queue.add(newQueue);
		return match;
	}</text>
}
}
@helper CallProduction(ProductionRule production)
{
	switch(production.Type) {
		case ProductionRuleType.Start:
			@:stackHandler.push(@(production.RuleName).class);
			break;
		case ProductionRuleType.End:
			@:stackHandler.collapse(@(production.RuleName).class);
			break;
		case ProductionRuleType.Process:
			@:stackHandler.consume(token);
			break;
	}
}
@helper HandleParserError(IEnumerable<string> expectedTokens)
{<text>
		List<String> expectedTokens = asList("@Raw(string.Join("\", \"", expectedTokens))");
		throw new UnexpectedTokenException(token.toString(), expectedTokens, token.getLineNum());</text>}
@helper matchToken(TokenType tokenType)
{<text>token.getType().equals(@(tokenType)Token)</text>}