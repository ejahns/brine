//	  This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
//
//	  Changes to this file may cause incorrect behavior and will be lost if
//	  the code is regenerated.
@using Berp;
package com.github.ejahns;

import java.util.List;
import java.util.Deque;
import java.util.ArrayDeque;
import java.util.Queue;

import com.github.ejahns.ParserException.*;
@foreach(var rule in Model.RuleSet.DerivedRules.Where(r => !r.TempRule))
{<text>import com.github.ejahns.model.@(rule.Name);
</text>}
import com.github.ejahns.token.Token;
import com.github.ejahns.token.TokenProvider;
import com.github.ejahns.interfaces.GherkinElement;

import static com.github.ejahns.Parser.TokenType.*;
import static java.util.Arrays.*;

public class @Model.ParserClassName {

	private StackHandler<GherkinElement, Token> stackHandler;
	private TokenProvider provider;
	private boolean collectErrors = false;
    private List<String> errors;

	public enum TokenType {
		@foreach(var rule in Model.RuleSet.TokenRules)
		{<text>		@rule.Name.Replace("#", "")Token,
</text>}		;
		@@Override
		public String toString() {
			return name().replace("Token", "");
		}
		}

	@Model.RuleSet.StartRule.Name parse(TokenProvider provider) {
		return parse(provider, new FeatureBuildingStackHandler());
	}

	@Model.RuleSet.StartRule.Name parse(TokenProvider provider, List<String> errors) {
		this.collectErrors = true;
		this.errors = errors;
		return parse(provider, new FeatureBuildingStackHandler(errors));
	}

	private @Model.RuleSet.StartRule.Name parse(TokenProvider provider, StackHandler<GherkinElement, Token> stackHandler) {
		this.provider = provider;
		this.stackHandler = stackHandler;

		stackHandler.push(Feature.class);
		int state = 0;
		Token token;
		do {
			token = provider.next();
			state = matchToken(state, token);
		} while (!token.isEOF());

		return (@Model.RuleSet.StartRule.Name) stackHandler.resolve();
	}

	private int matchToken(int state, Token token) {
		int newState;
		switch(state) {
		@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
		{
			@:case @state.Id:
				@:newState = matchTokenAt_@(state.Id)(token);
				@:break;
		}
			default:
				throw new IllegalStateException("Unknown state: " + state);
		}
		return newState;
	}
@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
{
<text>
	// @Raw(state.Comment)
	private int matchTokenAt_@(state.Id)(Token token) {
		@foreach(var transition in state.Transitions)
		{
		@:if (@matchToken(transition.TokenType)) {
			if (transition.LookAheadHint != null)
			{
			@:if (lookahead_@(transition.LookAheadHint.Id)())
			@:{
			}
			foreach(var production in transition.Productions)
			{
				@CallProduction(production)
			}
			@:return @transition.TargetState;
			if (transition.LookAheadHint != null)
			{
			@:}
			}
		@:}
		}
		@HandleParserError(state.Transitions.Select(t => t.TokenType.ToString()).Distinct(), state)
	}</text>
}
@foreach(var lookAheadHint in Model.RuleSet.LookAheadHints)
{
<text>
	private boolean lookahead_@(lookAheadHint.Id)() {
		Token token;
		Deque<Token> newQueue = new ArrayDeque<>();
		boolean match = false;
		do
		{
			token = provider.next();
			newQueue.add(token);

			if (false
			@foreach(var tokenType in lookAheadHint.ExpectedTokens)
			{
				@:|| @matchToken(tokenType)
			}
			)
			{
				match = true;
				break;
			}
		} while (false
		@foreach(var tokenType in lookAheadHint.Skip)
		{
			@:|| @matchToken(tokenType)
		}
		);
		provider.addToFront(newQueue);
		return match;
	}</text>
}
}
@helper CallProduction(ProductionRule production)
{
	switch(production.Type) {
		case ProductionRuleType.Start:
			@:stackHandler.push(@(production.RuleName).class);
			break;
		case ProductionRuleType.End:
			@:stackHandler.popConsume(@(production.RuleName).class);
			break;
		case ProductionRuleType.Process:
			@:stackHandler.consume(token);
			break;
	}
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{<text>
		List<String> expectedTokens = asList("@Raw(string.Join("\", \"", expectedTokens))");
		UnexpectedTokenException error = new UnexpectedTokenException(token.toString(), expectedTokens, token.getLineNum());
		if(!collectErrors) {
			throw error;
		}
		errors.add(error.toString());
		return @state.Id;</text>}
@helper matchToken(TokenType tokenType)
{<text>token.getType().equals(@(tokenType)Token)</text>}