//	  This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
//
//	  Changes to this file may cause incorrect behavior and will be lost if
//	  the code is regenerated.
@using Berp;
package com.github.ejahns;

import java.util.ArrayDeque;
import java.util.Queue;

@foreach(var rule in Model.RuleSet.DerivedRules.Where(r => !r.TempRule))
{<text>import com.github.ejahns.model.@(rule.Name);
</text>}

import static com.github.ejahns.Parser.TokenType.*;

public class @Model.ParserClassName {

	private static final ThreadLocal<GherkinElementStack> STACK = new ThreadLocal<>();
    private static final ThreadLocal<TokenQueue> QUEUE = new ThreadLocal<>();

	public enum TokenType {
		@foreach(var rule in Model.RuleSet.TokenRules)
		{<text>		@rule.Name.Replace("#", "")Token,
</text>}
	}

	public @Model.RuleSet.StartRule.Name parse(TokenQueue queue) {
		QUEUE.set(queue);
        STACK.set(new GherkinElementStack());
		STACK.get().push(@(Model.RuleSet.StartRule.Name).class);
		int state = 0;
		Token token;
		do {
			token = queue.next();
			state = matchToken(state, token);
		} while (!token.isEOF());

		STACK.get().collapse(@(Model.RuleSet.StartRule.Name).class);

		return STACK.get().resolve();
	}

	private int matchToken(int state, Token token) {
		int newState;
		switch(state) {
		@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
		{
			@:case @state.Id:
				@:newState = matchTokenAt_@(state.Id)(token);
				@:break;
		}
			default:
				throw new IllegalStateException("Unknown state: " + state);
		}
		return newState;
	}
@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
{
<text>
	// @Raw(state.Comment)
	private int matchTokenAt_@(state.Id)(Token token) {
		@foreach(var transition in state.Transitions)
		{
		@:if (@matchToken(transition.TokenType)) {
			if (transition.LookAheadHint != null)
			{
			@:if (lookahead_@(transition.LookAheadHint.Id)(token))
			@:{
			}
			foreach(var production in transition.Productions)
			{
				@CallProduction(production)
			}
			@:return @transition.TargetState;
			if (transition.LookAheadHint != null)
			{
			@:}
			}
		@:}
		}
		@HandleParserError()
	}</text>
}
@foreach(var lookAheadHint in Model.RuleSet.LookAheadHints)
{
<text>
	private boolean lookahead_@(lookAheadHint.Id)(Token currentToken) {
		Token token;
		Queue<Token> newQueue = new ArrayDeque<Token>();
		boolean match = false;
		do
		{
			token = QUEUE.get().next();
			newQueue.add(token);

			if (false
			@foreach(var tokenType in lookAheadHint.ExpectedTokens)
			{
				@:|| @matchToken(tokenType)
			}
			)
			{
				match = true;
				break;
			}
		} while (false
		@foreach(var tokenType in lookAheadHint.Skip)
		{
			@:|| @matchToken(tokenType)
		}
		);
		QUEUE.get().add(newQueue);
		return match;
	}</text>
}
}
@helper CallProduction(ProductionRule production)
{
	switch(production.Type) {
		case ProductionRuleType.Start:
			@:STACK.get().push(@(production.RuleName).class);
			break;
		case ProductionRuleType.End:
			@:STACK.get().collapse(@(production.RuleName).class);
			break;
		case ProductionRuleType.Process:
			@:STACK.get().consume(token);
			break;
	}
}
@helper HandleParserError()
{<text>throw new IllegalStateException();</text>}
@helper matchToken(TokenType tokenType)
{<text>token.getType().equals(@(tokenType)Token)</text>}